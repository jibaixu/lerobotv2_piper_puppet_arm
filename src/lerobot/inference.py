# Copyright 2024 The HuggingFace Inc. team. All rights reserved.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""
Inference episode. Actions for the robot can be either generated by a policy, and generated by a teleoprator when reset the environment.

Example inference with piper:

```shell

python -m lerobot.inference \
  --robot.type=piper_follower \
  --robot.id=piper_follower \
  --robot.cameras='{image: {"type": "intelrealsense", "serial_number_or_name": "317422074519", "width": 640, "height": 360, "fps": 30}, wristimage: {"type": "intelrealsense", "serial_number_or_name": "317422075321", "width": 640, "height": 360, "fps": 30}}' \
  --teleop.type=piper_leader \
  --teleop.id=piper_leader \
  --pretrained_path=/path/to/model_ckpt \
  --dataset_path=/path/to/dataset \
  --num_episodes=2 \
  --display_data=true \

"""
def debug_on():
    import sys
    sys.argv.extend([
        "--robot.type=piper_follower",
        "--robot.id=piper_follower",
        "--teleop.type=piper_leader",
        "--teleop.id=piper_leader",
        "--pretrained_path=/path/to/model_ckpt",
        "--dataset_path=/path/to/dataset",
        "--num_episodes=2",
        "--display_data=true",
    ])
# debug_on()

import logging
import time
from dataclasses import asdict, dataclass
from pathlib import Path
from pprint import pformat
from typing import List

from lerobot.cameras import (  # noqa: F401
    CameraConfig,  # noqa: F401
)
from lerobot.cameras.opencv.configuration_opencv import OpenCVCameraConfig  # noqa: F401
from lerobot.cameras.realsense.configuration_realsense import RealSenseCameraConfig  # noqa: F401
from lerobot.configs import parser
from lerobot.configs.policies import PreTrainedConfig
from lerobot.datasets.image_writer import safe_stop_image_writer
from lerobot.datasets.lerobot_dataset import LeRobotDatasetMetadata,LeRobotDataset
from lerobot.datasets.utils import build_dataset_frame, hw_to_dataset_features
from lerobot.policies.factory import make_policy
from lerobot.policies.pretrained import PreTrainedPolicy
from lerobot.robots import (  # noqa: F401
    Robot,
    RobotConfig,
    koch_follower,
    make_robot_from_config,
    so100_follower,
    so101_follower,
    piper_follower,
)
from lerobot.teleoperators import (  # noqa: F401
    Teleoperator,
    TeleoperatorConfig,
    koch_leader,
    make_teleoperator_from_config,
    so100_leader,
    so101_leader,
    piper_leader,
)
from lerobot.teleoperators.keyboard.teleop_keyboard import KeyboardTeleop
from lerobot.utils.control_utils import (
    init_keyboard_listener,
    is_headless,
    predict_action,
    sanity_check_dataset_name,
    sanity_check_dataset_robot_compatibility,
)
from lerobot.utils.robot_utils import busy_wait
from lerobot.utils.utils import (
    get_safe_torch_device,
    init_logging,
    log_say,
)
from lerobot.utils.visualization_utils import _init_rerun, log_rerun_data
from lerobot.policies.diffusion.modeling_diffusion import DiffusionPolicy


@dataclass
class InferenceConfig:
    robot: RobotConfig
    # Whether to control the robot with a teleoperator
    teleop: TeleoperatorConfig
    # Control the robot with a pretrained policy
    pretrained_path: str
    # To get features of dataset and constuct data frames
    dataset_path: str
    # Num of inference episodes
    num_episodes: int
    # Limit the maximum frames per second.
    fps: int = 30
    # Number of seconds for data inferring for each episode.
    episode_time_s: int | float = 3600
    # Number of seconds for resetting the environment after each episode.
    reset_time_s: int | float = 3600
    # Display all cameras on screen
    display_data: bool = False
    # Use vocal synthesis to read events.
    play_sounds: bool = True


@safe_stop_image_writer
def inference_loop(
    robot: Robot,
    events: dict,
    fps: int,
    dataset: LeRobotDataset | None = None,
    teleop: Teleoperator | None = None,
    policy: PreTrainedPolicy | None = None,
    control_time_s: int | None = None,
    single_task: str | None = None,
    display_data: bool = False,
):
    # if policy is given it needs cleaning up
    if policy is not None:
        policy.reset()

    timestamp = 0
    start_episode_t = time.perf_counter()
    while timestamp < control_time_s:
        start_loop_t = time.perf_counter()

        if events["exit_early"]:
            events["exit_early"] = False
            break

        observation = robot.get_observation()

        if policy is not None or dataset is not None:
            observation_frame = build_dataset_frame(dataset.features, observation, prefix="observation")

        if policy is not None:
            action_values = predict_action(
                observation_frame,
                policy,
                get_safe_torch_device(policy.config.device),
                policy.config.use_amp,
                task=single_task,
                robot_type=robot.robot_type,
            )
            action = {key: action_values[i].item() for i, key in enumerate(robot.action_features)}
        elif policy is None and isinstance(teleop, Teleoperator):
            action = teleop.get_action()
        else:
            logging.info(
                "No policy or teleoperator provided, skipping action generation."
                "This is likely to happen when resetting the environment without a teleop device."
                "The robot won't be at its rest position at the start of the next episode."
            )
            continue

        # Action can eventually be clipped using `max_relative_target`,
        robot.send_action(action)

        if display_data:
            log_rerun_data(observation, action)

        dt_s = time.perf_counter() - start_loop_t
        busy_wait(1 / fps - dt_s)

        timestamp = time.perf_counter() - start_episode_t


@parser.wrap()
def inference(cfg: InferenceConfig):
    init_logging()
    logging.info(pformat(asdict(cfg)))
    if cfg.display_data:
        _init_rerun(session_name="inferencing")

    robot = make_robot_from_config(cfg.robot)
    teleop = make_teleoperator_from_config(cfg.teleop)

    dataset_metadata = LeRobotDatasetMetadata(cfg.dataset_path)
    dataset = LeRobotDataset(cfg.dataset_path)
    # 取第0个任务
    single_task = dataset_metadata.tasks[0]

    # Load pretrained policy
    policy = DiffusionPolicy.from_pretrained(cfg.pretrained_path)

    robot.connect()
    teleop.connect()

    listener, events = init_keyboard_listener()

    inferred_episodes = 0
    while inferred_episodes < cfg.num_episodes and not events["stop_inferring"]:
        log_say(f"Inferring episode {cfg.num_episodes}", cfg.play_sounds)
        inference_loop(
            robot=robot,
            events=events,
            fps=cfg.fps,
            teleop=teleop,
            policy=policy,
            dataset=dataset,
            control_time_s=cfg.episode_time_s,
            single_task=single_task,
            display_data=cfg.display_data,
        )

        # Execute a few seconds without recording to give time to manually reset the environment
        # Skip reset for the last episode to be recorded
        if not events["stop_inferring"] and (
            (inferred_episodes < cfg.num_episodes - 1) or events["reinfer_episode"]
        ):
            log_say("Reset the environment", cfg.play_sounds)
            inference_loop(
                robot=robot,
                events=events,
                fps=cfg.fps,
                teleop=teleop,
                control_time_s=cfg.reset_time_s,
                single_task=single_task,
                display_data=cfg.display_data,
            )

        if events["reinfer_episode"]:
            log_say("Re-infer episode", cfg.play_sounds)
            events["reinfer_episode"] = False
            events["exit_early"] = False
            continue

        inferred_episodes += 1

    log_say("Stop inferring", cfg.play_sounds, blocking=True)

    robot.disconnect()

    if not is_headless() and listener is not None:
        listener.stop()

    log_say("Exiting", cfg.play_sounds)


if __name__ == "__main__":
    inference()
